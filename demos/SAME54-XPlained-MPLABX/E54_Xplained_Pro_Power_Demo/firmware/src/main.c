/**
 * @file main.c
 *
 * This is the main entry point for the SAM E54 Xplained Pro Power Demo which
 * demonstrates power-saving modes for the SAM E54.
 *
 * When launched, the program prints a header on the serial output and enters
 * Active (full-power) mode.  It prompts you to press SW0 (the user button on
 * the E54 Xplained Pro board) to cycle through Active, Standby and Hibernate
 * modes.
 *
 * You can launch the Microchip Data Visualizer and open its Power Analysis
 * window in order to monitor how the power changes in each of the three modes.
 */

 //DOM-IGNORE-BEGIN
 /******************************************************************************
 MIT License

 Copyright (c) 2020 R. Dunbar Poor <rdpoo@gmail.com>

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
*******************************************************************************/
//DOM-IGNORE-END

// =============================================================================
// include files

#include "definitions.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>

// =============================================================================
// types and definitions

#define VERSION_NUMBER "1.0.0"

// how long we stay in hibernation mode before the RTC wakes us
#define HIBERNATION_S 30

typedef enum {
  STATE_ACTIVE,
  STATE_STANDBY,
  STATE_HIBERNATE,
} state_t;

// =============================================================================
// forward declarations to local functions

static state_t process_active_state(void);
static state_t process_standby_state(void);
static state_t process_hibernate_state(void);
static void will_sleep(void);
static void did_wake(void);
static void eic_callback(uintptr_t context);
static void rtc_callback(RTC_TIMER32_INT_MASK intCause, uintptr_t context);

// =============================================================================
// local (static) storage

volatile static bool s_button_was_pressed;

// =============================================================================
// main code starts here

/**
 * This sketch cycles the processor through three different power modes:
 *
 * Active Mode:    The processor is running in full-power mode, waiting for a
 *                 button push before entering Standby Mode.
 * Standby Mode:   The processor is in standby mode, waiting for button push
 *                 before entering Hibernate mode.
 * Hibernate Mode: The processor is hibernate mode, waiting 30 seconds for an
 *                 RTC interrupt to bring it out of hibernate mode.
 *
 * Implementation Note: although the progression through the three states is
 * straightforward, the end condition for each state is sightly different:
 *
 * Active Mode:    The processor does a busy wait, examining the contents of
 *                 s_button_was_pressed -- which is set in the iec_callback --
 *                 before progressing to the next state.
 * Standby Mode:   The processor is halted in a WFI (Wait For Interrupt) state.
 *                 A interrupt in iec_callback, generated by a button push,
 *                 wakes the processor.
 * Hibernate Mode: The processor (and most peripherals) are shut down.  The only
 *                 things that can bring the processor out of hibernation is an
 *                 external reset or an RTC interrupt.  We configure the RTC to
 *                 generate a counter match interrupt after 30 seconds, which
 *                 wakes the processor.  Since waking from hibernation causes
 *                 a system reset, the program simply starts over.
 */
int main(void) {
  state_t state = STATE_ACTIVE;

  SYS_Initialize(NULL);
  // Choose the low-power regulator
  SUPC_SelectVoltageRegulator(SUPC_VREGSEL_BUCK);
  // Register our IEC (button push) and RTC callbacks.
  EIC_CallbackRegister(EIC_PIN_15, eic_callback, (uintptr_t)NULL);
  RTC_Timer32CallbackRegister(rtc_callback, (uintptr_t)NULL);
  // Enable interrupt on the RTC
  RTC_Timer32InterruptEnable(RTC_TIMER32_INT_MASK_CMP0);
  printf("\n\nSAM E54 Xplained Power Demo, v%s", VERSION_NUMBER);

  while(true) {
    switch(state) {
      case STATE_ACTIVE:
        state = process_active_state();
        // arrives here after busy-wait button push
        break;
      case STATE_STANDBY:
        state = process_standby_state();
        // arrives here after waking from STANDBY mode
        break;
      case STATE_HIBERNATE:
        state = process_hibernate_state();
        // never arrives here because wake from HIBERNATE is always a reset.
        break;
      default:
        state = process_active_state();
    }
  }
   // never gets here...
   return (EXIT_FAILURE);
 }

// =============================================================================
// local function definitions

static state_t process_active_state() {
  printf("\nEntering ACTIVE mode.  Press SW0 to enter STANDBY mode:");
  will_sleep();

  s_button_was_pressed = false;
  while (!s_button_was_pressed) {
    // busy wait
  }

  // Arrive here when the s_button_was_pressed was set true at interrupt level.
  did_wake();
  return STATE_STANDBY;
}

static state_t process_standby_state() {
  printf("\nEntering STANDBY mode.  Press SW0 to enter HIBERNATE mode: ");
  will_sleep();

  // There appears to be a bug in the E54 silicon that causes the DFLL to lose
  // the state of the .FINE bits across STANDBY / wake events.  As a workaround,
  // we save the DFLL state prior to STANDBY and restore it upon waking.
  uint32_t saved_dfllval = OSCCTRL_REGS->OSCCTRL_DFLLVAL;
  PM_StandbyModeEnter();
  OSCCTRL_REGS->OSCCTRL_DFLLVAL = saved_dfllval;

  // arrive here when an EIC interrupt (i.e. button push) wakes processor
  did_wake();
  return STATE_HIBERNATE;
}

static state_t process_hibernate_state() {
  uint32_t wake_at;
  printf("\nEntering HIBERNATE mode.  Hibernating for %d seconds...",
         HIBERNATION_S);
  will_sleep();

  // Condition the RTC to generate a compare match interupt in HIBERNATION_S
  // seconds
  RTC_Timer32Start();
  wake_at = RTC_Timer32CounterGet() + RTC_Timer32FrequencyGet() * HIBERNATION_S;
  RTC_Timer32Compare0Set(wake_at);
  PM_HibernateModeEnter();
  // The only way to exit from Hibernate mode is from an external reset or one
  // of the RTC interrupts (e.g. Counter Match or Tamper Interrupt).  However,
  // waking from Hibernate mode causes a system reset, so we never actually
  // arrive here (unless running under the debugger).

  did_wake();
  return STATE_ACTIVE;  // ignored
}

static void will_sleep(void) {
  // assure serial output has completed
  while (!SERCOM2_USART_TransmitComplete());
}

static void did_wake(void) {
  // restore anything modified in will_sleep()
}

static void eic_callback(uintptr_t context) {
  // Arrive here at interrupt level when the SW0 button is pushed.  In addition
  // to setting the s_button_was_pressed flag, the interrupt also serves to wake
  // the processor if it was in Standby mode.
  s_button_was_pressed = true;
}

static void rtc_callback(RTC_TIMER32_INT_MASK intCause, uintptr_t context) {
  // arrive here on an RTC interrupt, in this case, when the there is a compare
  // match.  No other action is required; we use the interrupt only to wake the
  // processor from Hibernate mode.
}
